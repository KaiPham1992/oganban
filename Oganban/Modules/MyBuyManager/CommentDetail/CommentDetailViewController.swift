//
//  CommentDetailViewController.swift
//  Oganban
//
//  Created DINH VAN TIEN on 1/12/19.
//  Copyright © 2019 Coby. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit

class CommentDetailViewController: BaseViewController {

	var presenter: CommentDetailPresenterProtocol?
    
    @IBOutlet weak var vPostCommentView: PostCommentView!
    @IBOutlet weak var bottomConstant: NSLayoutConstraint!
    @IBOutlet weak var heightConstant: NSLayoutConstraint!
    @IBOutlet weak var tbDetail: UITableView!
    
    var tapGesture: UITapGestureRecognizer!
    var listComment = [CommentEntity]() {
        didSet {
            tbDetail.reloadData()
        }
    }
    
    //
    // 1. get API Cha listComment
    // 2. get con listComment[0].subcomment = API con
    //

    var recordId: String?
    var commentId: String?
    var sectionSentSubComment: Int?
    
	override func viewDidLoad() {
        super.viewDidLoad()
        addKeyboardNotification()
        vPostCommentView.delegate = self
        configureTable()
        
        NotificationCenter.default.removeObserver(self)
        
        NotificationCenter.default.addObserver(self, selector: #selector(didDeleteSubcomment), name: AppConstant.deleteSubComment, object: nil)
        
        NotificationCenter.default.addObserver(self, selector: #selector(didDeleteComment), name: AppConstant.deleteComment, object: nil)
//        self.presenter?.getCommentList(recordId: self.recordId&, offset: 0)
        self.presenter?.getCommentParent(commentID: commentId&)
        
        tabBarController?.tabBar.isHidden = true
    }
    
    @objc func didDeleteSubcomment(notification: Notification) {
        guard let id = notification.object as? String else { return }
        for comment in listComment {
            for i in 0..<comment.subComment.count {
                if comment.subComment[i].id == id {
                    comment.subComment.remove(at: i)
                    break
                }
            }
        }
        
        tbDetail.reloadData()
    }
    
    @objc func didDeleteComment(notification: Notification) {
        guard let id = notification.object as? String else { return }
        for i in 0..<listComment.count {
            if listComment[i].id == id {
                listComment.remove(at: i)
                break
            }
        }
        
        tbDetail.reloadData()
    }
    
    override func setUpNavigation() {
        super.setUpNavigation()
        addBackToNavigation()
        setTitleNavigation(title: "Danh sách bình luận")
    }
}

extension CommentDetailViewController: CommentDetailViewProtocol {
    
    func didGetCommentParent(comment: CommentEntity?) {
        guard let _comment = comment else { return }
        self.listComment.append(_comment)
        self.recordId = _comment.recordId
        self.presenter?.getCommentChild(commentID: commentId&, offset: 0, limit: 20)
    }
    
    func didGetCommentChild(subComment: CommentChildEntity?) {
        guard let _subComment = subComment else { return }
        if self.listComment.count > 0 {
            self.listComment[0].subComment = _subComment.subCommnent
            tbDetail.reloadData()
        }
        
    }
    
    func didGetComment(commentResponseEntity: CommentResponseEntity?) {
        guard let _listComment = commentResponseEntity?.listComment else { return }
        
        self.listComment = _listComment
    }
    
    func didSendComment(comment: CommentEntity?) {
        guard let _comment = comment else { return }
        insertComment(comment: _comment)
    }
    
    func didSendSubComment(comment: SubCommentEntity?) {
        guard let _comment = comment else { return }
        guard let section = sectionSentSubComment else { return }
        insertSubComment(section: section, subComment: _comment)
    }
    
}

// MARK: handle view post
extension CommentDetailViewController: PostCommentViewDelegate {
    func postCommentView(_ postCommentView: PostCommentView, changeHeight height: CGFloat) {
        heightConstant.constant = height
    }
    
    func postCommentView(_ postCommentView: PostCommentView, sendComment comment: String) {
        if postCommentView == vPostCommentView {
//            let param = SendCommentParam(recordId: recordId&, comment: comment&, isReComment: "0")
//            presenter?.sendComment(param: param)
            
            let indexSection = 0
            sectionSentSubComment = indexSection
            if indexSection < self.listComment.count {
                let commentId = self.listComment[indexSection].id&
                let param = SendCommentParam(recordId: self.recordId&, comment: comment, commentId: commentId, isReComment: "1")
                presenter?.sendSubComment(param: param)
            }
        }
        
    }
    
    override func keyboardWillShow(_ notification: Notification) {
        print("addGesture")
        addGesture()
    }
    
    override func keyboardWillHide() {
        if tapGesture != nil {
            self.view.removeGestureRecognizer(tapGesture)
        }
    }
    
    func addGesture() {
        if tapGesture == nil {
            tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGestureExecute))
        }
        
        self.view.addGestureRecognizer(tapGesture)
    }
    
    @objc func tapGestureExecute() {
        self.view.endEditing(true)
    }
}

// MARK: helper
extension CommentDetailViewController {
    
    func insertSubComment(section: Int, subComment: SubCommentEntity) {
        self.listComment[section].subComment.append(subComment)
        
        tbDetail.beginUpdates()
        let indexPath = IndexPath(item: self.listComment[section].subComment.count, section: section)
        tbDetail.insertRows(at: [indexPath], with: .none)
        tbDetail.endUpdates()
        
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.3) {
            self.tbDetail.scrollToBottom(section: section)
        }
    }
    
    func insertComment(comment: CommentEntity) {
        self.listComment.append(comment)
        tbDetail.reloadData()
        
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.3) {
            self.tbDetail.scrollToBottom()
        }
        
    }
}

// MARK: table
extension CommentDetailViewController: UITableViewDelegate, UITableViewDataSource {
    func configureTable() {
        tbDetail.delegate = self
        tbDetail.dataSource = self
        tbDetail.registerXibFile(CommentCell.self)
        tbDetail.registerXibFile(SubCommentCell.self)
        tbDetail.registerXibFile(ReplyCommentCell.self)
        tbDetail.separatorStyle = .none
        tbDetail.rowHeight = UITableView.automaticDimension
        tbDetail.estimatedRowHeight = 150
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        switch indexPath.row {
        case 0:
            let cell = tbDetail.dequeue(CommentCell.self, for: indexPath)
            cell.comment = listComment[indexPath.section]
            return cell
//        case self.listComment[indexPath.section].subComment.count + 1:
//            let cell = tbDetail.dequeue(ReplyCommentCell.self, for: indexPath)
//            cell.vPostCommentView.tag = indexPath.section
//            cell.vPostCommentView.delegate = self
//            return cell
        default:
            let cell = tbDetail.dequeue(SubCommentCell.self, for: indexPath)
            cell.subComment = self.listComment[indexPath.section].subComment[indexPath.item - 1]
            return cell
        }
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        if self.listComment.count > 0 {
            return self.listComment[section].subComment.count + 1
        }
        return 0
        
    }
}



